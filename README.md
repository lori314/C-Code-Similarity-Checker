# C语言代码相似度检测器 (数据结构课程设计)

## 1. 项目背景

这是我在大一“数据结构”课程中完成的期末大作业。

课程布置的题目是实现一个**C语言代码的相似度检测工具**。基础要求是，通过读取多份C代码文件，利用**编辑距离 (Levenshtein Distance)** 算法来判断它们之间的相似性。

在完成了课程的基础要求后，我希望能更深入地探索这个课题。我的**额外目标**不仅仅是实现功能，更是要**挑战算法的性能极限**。因此，我将主要精力投入到了**对核心算法的性能分析与优化上**。

---

## 2. 实现思路

为了实现这个目标，我设计了一个两阶段的处理流程：

#### **第一阶段：代码的“结构化”与“归一化”**

我认为，决定代码核心逻辑的不是变量名或函数名，而是代码的**结构**和所使用的**关键字**。因此，我编写了一个自定义的词法分析器 (`wash_cat`函数) 来处理输入的C代码。它的主要工作是：

*   **读取C代码源文件** (`codes.txt`) 和一个预定义的C语言**关键字列表** (`keepwords.txt`)。
*   **词法单元化 (Tokenization):** 遍历代码，保留所有的C语言关键字和符号。
*   **标识符归一化:** 将所有的非关键字标识符（即程序员自定义的变量名和函数名）统一替换为一个特殊的标识符，如`"FUNC"`。

通过这个过程，任何一份C语言代码都会被转换成一个只包含其“结构骨架”的字符串。

#### **第二阶段：使用“编辑距离”算法计算相似度**

在获得了每份代码的“结构骨架”字符串后，我需要一个算法来量化它们之间的相似程度。我选择了经典的**编辑距离 (Levenshtein Distance)** 算法。

*   **算法核心:** 编辑距离指两个字符串之间，由一个转成另一个所需的最少编辑操作（插入、删除、替换）次数。距离越小，代表两个字符串越相似。
*   **高效实现:** 我使用**动态规划 (Dynamic Programming)** 的方法实现了这个算法。通过构建一个二维的DP表，可以在 O(n*m) 的时间复杂度内计算出两个字符串的编辑距离。

---

## 3. 优化探索

在实现了基础功能后，我发现程序在处理大量或较长的代码文件时，性能并不理想。于是，我将后续的工作重心全部放在了**性能优化**上。这部分工作是课程要求之外，我自主完成的。我的主要优化思路如下：

#### **优化一：关键字查找算法的思考与迭代**

*   **初步实现**: 我最初使用`qsort`对关键字列表进行多轮排序，并实现了一个分段的线性查找函数 `search`。
*   **反思与简化**: 在后续迭代中，我意识到对于中等规模的固定关键字集合，更直接的查找方式可能更具性价比。这个过程让我深刻理解到，**算法的选择需要平衡实现复杂度和在特定场景下的实际性能**。

#### **优化二 (核心)：为编辑距离算法设计并实现剪枝策略**

这是我投入精力最多的优化点。标准的编辑距离算法需要计算一个完整的 `n*m` 大小的动态规划矩阵，当字符串很长时，这非常耗时。

*   **发现瓶颈**: 我意识到，当我们的目标只是判断相似度是否“超过95%”时，并不需要算出精确的编辑距离。如果两个字符串的差异过大，我们可以提前终止计算。
*   **设计剪枝策略**: 基于此，我设计并实现了两种**剪枝 (Pruning)** 策略：
    1.  **长度差异剪枝:** 在进行DP计算前，先比较两个字符串的长度。如果长度差异本身就超过了5%，那么相似度不可能达到95%，直接判定为不相似，跳过后续所有计算。
    2.  **DP计算中动态剪枝:** 在DP矩阵的计算过程中，我实时监控当前行的最小编辑距离。如果这个中间值已经预示着最终结果不可能达到95%的相似度，就立即中断计算，返回“不相似”的结果。
*   **成果**: 这两种剪枝策略，尤其是在处理大量不相似的代码对时，极大地减少了不必要的计算，显著提升了程序的整体运行效率。

这个从发现瓶颈，到设计优化策略，再到编码实现的全过程，是我在这个项目中最大的收获。它让我真正实践了“**用算法思维优化实际问题**”的理念。

---

## 4. 技术汇总

*   **C语言:** 熟练使用指针、结构体、动态内存分配 (`malloc`)、文件I/O和各种字符串处理函数。
*   **核心算法:** 实现了**动态规划**版本的**编辑距离**算法，并对其进行了**剪枝优化**。
*   **数据结构应用:** 使用数组、结构体数组来存储和管理解析后的代码信息、函数列表等。
*   **词法分析:** 编写了能够区分关键字和自定义标识符的简易解析器，这是编译原理的基础实践。
*   **性能优化:** 能够主动发现算法瓶颈，并设计和实现有效的优化策略。

---

## 5. 如何编译与运行

```bash
# 编译主程序 (请根据你的主文件名修改)
gcc your_main_file.c -o code_similarity_checker -lm

# 运行程序
./code_similarity_checker
```
程序会读取默认的`codes.txt`和`keepwords.txt`（可以根据实际路径调整），并输出它判定为相似的代码对。

---

## 6. 学习与反思

这个项目是我学习C语言和算法的第一个综合性挑战。现在回头看，虽然在代码风格和健壮性上还有提升空间（比如对输入格式的错误处理、对字符编码的注意等），但它成功地将数据结构、算法、文件操作和基础的编译原理知识结合起来，解决了一个真实而有趣的问题。这个不断迭代和优化的过程，是我最宝贵的收获。
